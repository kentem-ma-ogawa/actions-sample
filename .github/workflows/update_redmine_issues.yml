name: Update Redmine Issues

on:
  pull_request:
    types: [opened, closed]

jobs:
  update_redmine_issues:
    if: >
      (github.event.action != 'closed' || github.event.pull_request.merged == true) &&
      (contains(github.head_ref, 'redmine') || contains(github.head_ref, 'bugfix'))
    runs-on: ubuntu-slim
    timeout-minutes: 5
    steps:
      # PRタイトルからRedmineのIssueIdを抽出
      - name: Extract Redmine Issue Ids
        id: extract_issue_ids
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request?.title || '';
            // "Redmine12345…" のようなテキストからチケット番号を抽出
            const issueIds = [...title.matchAll(/Redmine\s*(\d+)/gi)]
              .map(match => match?.[1] ?? '')
              .filter(id => id != '');
            
            if (issueIds.length <= 0) {
              core.setFailed('PRタイトルにチケット番号が含まれていないため、Redmineの更新ができませんでした。');
            }
            return issueIds;
          result-encoding: json
  
      # PR本文から <!-- Redmine: Start --> … <!-- Redmine: End --> の範囲を抽出
      - name: Extract Redmine Text From PR
        id: extract_pr_text
        if: ${{ github.event.action == 'closed' }}
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.pull_request?.body || '';
            // Redmine自動記入欄の（<!-- Redmine : Start --><!-- Redmine : End -->で囲まれた）テキストを抽出
            const redmineFieldRegex = /<!--\s*Redmine\s*:\s*Start\s*-->([\s\S]*?)<!--\s*Redmine\s*:\s*End\s*-->/i;
            const match = body.match(redmineFieldRegex);
            
            let textForRedmine = match?.[1] ?? '';
            if (textForRedmine.trim() === '') {
              textForRedmine = '';
            }
            
            core.info(`Text for redmine: ${textForRedmine}`);
            return textForRedmine;
          result-encoding: string

      # Pandocをインストール
      - name: Install Pandoc
        if: ${{ github.event.action == 'closed' && steps.extract_pr_text.outputs.result != '' }}
        uses: pandoc/actions/setup@v1
        with:
          version: 3.8
          
      # 抽出したテキスト（GFM）をPandocでTextileへ変換し、追記用テキストを作成
      - name: Convert GFM to Textile
        id: create_append_text
        if: ${{ github.event.action == 'closed' && steps.extract_pr_text.outputs.result != '' }}
        uses: actions/github-script@v7
        env:
          TEXT_FOR_REDMINE: ${{ steps.extract_pr_text.outputs.result }}
        with:
          script: |
            core.info(`textForRedmine: ${process.env.TEXT_FOR_REDMINE}`);
            const { execFileSync } = require('child_process');

            // Pandoc 実行（GFM → Textile）
            let converted = '';
            try {
              converted = execFileSync('pandoc', [
                '--sandbox',
                '--from', 'gfm-raw_html+hard_line_breaks',
                '--to', 'textile',
                '--wrap', 'none'
              ], { input: process.env.TEXT_FOR_REDMINE, encoding: 'utf8' });
            } catch (e) {
              core.setFailed(`Markdown(GFM）→ Textileへの変換に失敗: ${e.message}`);
            }
            core.info(`Converted PR text: ${converted}`);
            
            // 日付ヘッダーを作成
            const date = new Date();
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = (date.getDate()).toString().padStart(2, '0');
            const header = `> 【${year}/${month}/${day}】プルリクの内容を自動記入`;

            const newText = `${header}\r\n${converted}`;
            core.info(`NewText: ${newText}`);
            return newText;
          result-encoding: string

      # Redmineを更新
      - name: Update Redmine Issues
        uses: actions/github-script@v7
        env:
          ISSUE_IDS: ${{ steps.extract_issue_ids.outputs.result }}
          APPEND_TEXT: ${{ steps.create_append_text.outputs.result }}
          SAMPLE_NUMBER: ${{ secrets.SAMPLE_NUMBER }}
        with:
          script: |
            const issueIds = JSON.parse(process.env.ISSUE_IDS);
            const statusId = context.payload.action === 'opened' 
              ? 0
              : 1;
            const remarksId = 111;
            const appendText = process.env.APPEND_TEXT || '';
            const merged = context.payload.action === 'closed';
            
            core.info(`appendText: ${appendText}`);
            
            for (const issueId of issueIds) {
              core.info(`issueId: ${issueId}`);
              const originalText = '';

              const newText = originalText
                ? `${originalText}\r\n\r\n${appendText}`
                : appendText;

              // remarks（custom_fields）は appendText が空でなければ作成
              const remarks = appendText
                ? [{ id: remarksId, value: newText }]
                : [];
              core.info(`remarks: ${remarks}`);

              const issueUpdateBody = { issue: { status_id: statusId } };
              if (merged) {
                const authorId = 222;
                if (authorId != null)
                  issueUpdateBody.issue.assigned_to_id = authorId;
                
                if (remarks.length > 0) 
                  issueUpdateBody.issue.custom_fields = remarks;
                else
                  core.info('追記するテキストがありませんでした。');
              }

              const issueUpdateBodyJson = JSON.stringify(issueUpdateBody);
              core.info(`issueUpdateBody: ${issueUpdateBodyJson}`);
            }

            
